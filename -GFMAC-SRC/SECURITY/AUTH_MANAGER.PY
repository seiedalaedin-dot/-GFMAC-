#!/usr/bin/env python3
"""
Authentication Manager Module
Advanced Security and User Management
Developer: Seyed Aladdin Mousavi Jashni
"""

import asyncio
import logging
import jwt
import bcrypt
import secrets
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import qrcode
import io
import base64

from config import config

class AuthManager:
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ Ú†Ù†Ø¯Ù„Ø§ÛŒÙ‡"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.secret_key = config.SECURITY.get('JWT_SECRET', 'fallback-secret-key-change-in-production')
        self.algorithm = "HS256"
        
        # Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆÙ‚Øª Ú©Ø¯Ù‡Ø§ÛŒ ØªØ£ÛŒÛŒØ¯
        self.verification_codes = {}
        self.totp_secrets = {}
        
        # Ù„Ø§Ú¯ Ø§Ù…Ù†ÛŒØªÛŒ
        self.security_log = []
    
    async def initialize(self):
        """Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø³ÛŒØ³ØªÙ… Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª"""
        self.logger.info("ğŸ” Initializing Authentication Manager...")
        self.logger.info("âœ… Google Authenticator support: ENABLED")
        self.logger.info("âœ… SMS Verification support: ENABLED")
        self.logger.info("âœ… JWT Token system: ENABLED")
    
    async def create_user(self, user_data: Dict) -> Tuple[bool, Dict]:
        """
        Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ø§Ù…Ù†ÛŒØª Ú©Ø§Ù…Ù„
        
        Args:
            user_data: Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±
            
        Returns:
            Tuple[bool, Dict]: (Ù…ÙˆÙÙ‚ÛŒØª, Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯Ù‡)
        """
        try:
            self.logger.info(f"ğŸ‘¤ Creating new user: {user_data.get('email')}")
            
            # Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±
            is_valid, errors = self._validate_user_data(user_data)
            if not is_valid:
                return False, {'errors': errors}
            
            # Ù‡Ø´ Ú©Ø±Ø¯Ù† Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
            hashed_password = await self._hash_password(user_data['password'])
            
            # ØªÙˆÙ„ÛŒØ¯ Ø´Ù†Ø§Ø³Ù‡ ÛŒÚ©ØªØ§
            user_id = self._generate_user_id()
            
            # ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ
            google_auth_secret = self._generate_google_auth_secret()
            api_key = self._generate_api_key()
            
            user_profile = {
                'user_id': user_id,
                'email': user_data['email'],
                'mobile': user_data.get('mobile'),
                'password_hash': hashed_password,
                'security': {
                    'google_auth_secret': google_auth_secret,
                    'api_key': api_key,
                    'two_factor_enabled': True,
                    'login_attempts': 0,
                    'last_login': None,
                    'account_locked': False
                },
                'profile': {
                    'first_name': user_data.get('first_name'),
                    'last_name': user_data.get('last_name'),
                    'created_at': datetime.now().isoformat(),
                    'last_updated': datetime.now().isoformat()
                },
                'permissions': self._get_default_permissions(),
                'preferences': {
                    'notifications': True,
                    'theme': 'dark',
                    'language': 'fa'
                }
            }
            
            # ØªÙˆÙ„ÛŒØ¯ QR code Ø¨Ø±Ø§ÛŒ Google Authenticator
            qr_code_data = await self._generate_google_auth_qr_code(
                user_data['email'], google_auth_secret
            )
            
            self._log_security_event(
                'USER_CREATED',
                f"User {user_id} created successfully",
                user_id
            )
            
            return True, {
                'user': user_profile,
                'qr_code': qr_code_data,
                'setup_instructions': 'Scan QR code with Google Authenticator app'
            }
            
        except Exception as e:
            self.logger.error(f"âŒ User creation failed: {e}")
            self._log_security_event('USER_CREATION_FAILED', str(e))
            return False, {'error': str(e)}
    
    async def authenticate_user(self, credentials: Dict) -> Tuple[bool, Dict]:
        """
        Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø§ Ú†Ù†Ø¯ ÙØ§Ú©ØªÙˆØ±
        
        Args:
            credentials: Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÙˆØ±ÙˆØ¯
            
        Returns:
            Tuple[bool, Dict]: (Ù…ÙˆÙÙ‚ÛŒØª, Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª)
        """
        try:
            identifier = credentials.get('email') or credentials.get('mobile')
            self.logger.info(f"ğŸ” Authentication attempt for: {identifier}")
            
            # Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
            user = await self._get_user_by_identifier(identifier)
            if not user:
                self._log_security_event('AUTH_FAILED', f"User not found: {identifier}")
                return False, {'error': 'Invalid credentials'}
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ù‚ÙÙ„ Ø¨ÙˆØ¯Ù† Ø­Ø³Ø§Ø¨
            if user['security']['account_locked']:
                self._log_security_event('AUTH_FAILED', f"Account locked: {identifier}")
                return False, {'error': 'Account is locked'}
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
            password_valid = await self._verify_password(
                credentials['password'], 
                user['password_hash']
            )
            
            if not password_valid:
                # Ø§ÙØ²Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚
                user['security']['login_attempts'] += 1
                
                # Ù‚ÙÙ„ Ú©Ø±Ø¯Ù† Ø­Ø³Ø§Ø¨ Ù¾Ø³ Ø§Ø² Ûµ ØªÙ„Ø§Ø´ Ù†Ø§Ù…ÙˆÙÙ‚
                if user['security']['login_attempts'] >= 5:
                    user['security']['account_locked'] = True
                    self._log_security_event('ACCOUNT_LOCKED', f"Too many failed attempts: {identifier}")
                
                self._log_security_event('AUTH_FAILED', f"Invalid password: {identifier}")
                return False, {'error': 'Invalid credentials'}
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡â€ŒØ§ÛŒ
            if user['security']['two_factor_enabled']:
                two_factor_valid = await self._verify_two_factor(
                    user, 
                    credentials.get('two_factor_code')
                )
                
                if not two_factor_valid:
                    self._log_security_event('AUTH_FAILED', f"Invalid 2FA code: {identifier}")
                    return False, {'error': 'Invalid two-factor code'}
            
            # Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚
            user['security']['login_attempts'] = 0
            user['security']['last_login'] = datetime.now().isoformat()
            
            # ØªÙˆÙ„ÛŒØ¯ ØªÙˆÚ©Ù† JWT
            access_token = await self._generate_access_token(user)
            refresh_token = await self._generate_refresh_token(user)
            
            self._log_security_event(
                'AUTH_SUCCESS',
                f"User {user['user_id']} authenticated successfully",
                user['user_id']
            )
            
            return True, {
                'access_token': access_token,
                'refresh_token': refresh_token,
                'token_type': 'bearer',
                'expires_in': config.JWT_EXPIRATION.total_seconds(),
                'user': self._sanitize_user_data(user)
            }
            
        except Exception as e:
            self.logger.error(f"âŒ Authentication failed: {e}")
            self._log_security_event('AUTH_ERROR', str(e))
            return False, {'error': 'Authentication failed'}
    
    async def verify_google_auth(self, user_id: str, token: str) -> bool:
        """
        ØªØ£ÛŒÛŒØ¯ Ú©Ø¯ Google Authenticator
        
        Args:
            user_id: Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±
            token: Ú©Ø¯ ØªØ£ÛŒÛŒØ¯
            
        Returns:
            bool: Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯Ù† Ú©Ø¯
        """
        try:
            user = await self._get_user_by_id(user_id)
            if not user or 'google_auth_secret' not in user['security']:
                return False
            
            # Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ø§ÛŒØ¯ Ø§Ø² Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ TOTP Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´ÙˆØ¯
            # Ø¨Ø±Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡ØŒ ÛŒÚ© Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø³Ø§Ø¯Ù‡
            secret = user['security']['google_auth_secret']
            expected_code = self._generate_totp_code(secret)
            
            is_valid = token == expected_code
            
            if is_valid:
                self._log_security_event('2FA_SUCCESS', f"Google Auth verified for user {user_id}", user_id)
            else:
                self._log_security_event('2FA_FAILED', f"Invalid Google Auth code for user {user_id}", user_id)
            
            return is_valid
            
        except Exception as e:
            self.logger.error(f"Error verifying Google Auth: {e}")
            return False
    
    async def send_sms_verification(self, mobile: str) -> Tuple[bool, str]:
        """
        Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ SMS
        
        Args:
            mobile: Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„
            
        Returns:
            Tuple[bool, str]: (Ù…ÙˆÙÙ‚ÛŒØª, Ú©Ø¯ ØªØ£ÛŒÛŒØ¯)
        """
        try:
            # ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ ØªØ£ÛŒÛŒØ¯ Û¶ Ø±Ù‚Ù…ÛŒ
            verification_code = ''.join([str(secrets.randbelow(10)) for _ in range(6)])
            
            # Ø°Ø®ÛŒØ±Ù‡ Ú©Ø¯ Ø¨Ø§ Ø²Ù…Ø§Ù† Ø§Ù†Ù‚Ø¶Ø§
            self.verification_codes[mobile] = {
                'code': verification_code,
                'expires_at': datetime.now() + timedelta(minutes=5),
                'attempts': 0
            }
            
            # Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ø§ÛŒØ¯ Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ SMS Ø§Ø¯ØºØ§Ù… Ø´ÙˆØ¯
            self.logger.info(f"ğŸ“± SMS verification code for {mobile}: {verification_code}")
            
            self._log_security_event('SMS_SENT', f"Verification code sent to {mobile}")
            
            return True, verification_code
            
        except Exception as e:
            self.logger.error(f"âŒ SMS verification failed: {e}")
            return False, ""
    
    async def verify_sms_code(self, mobile: str, code: str) -> bool:
        """
        ØªØ£ÛŒÛŒØ¯ Ú©Ø¯ SMS
        
        Args:
            mobile: Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„
            code: Ú©Ø¯ ØªØ£ÛŒÛŒØ¯
            
        Returns:
            bool: Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯Ù† Ú©Ø¯
        """
        try:
            if mobile not in self.verification_codes:
                return False
            
            verification_data = self.verification_codes[mobile]
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù†Ù‚Ø¶Ø§
            if datetime.now() > verification_data['expires_at']:
                del self.verification_codes[mobile]
                return False
            
            # Ø¨Ø±Ø±Ø³ÛŒ ØªØ¹Ø¯Ø§Ø¯ ØªÙ„Ø§Ø´â€ŒÙ‡Ø§
            if verification_data['attempts'] >= 3:
                del self.verification_codes[mobile]
                return False
            
            verification_data['attempts'] += 1
            
            is_valid = code == verification_data['code']
            
            if is_valid:
                del self.verification_codes[mobile]
                self._log_security_event('SMS_VERIFIED', f"SMS code verified for {mobile}")
            else:
                self._log_security_event('SMS_FAILED', f"Invalid SMS code for {mobile}")
            
            return is_valid
            
        except Exception as e:
            self.logger.error(f"Error verifying SMS code: {e}")
            return False
    
    async def _generate_access_token(self, user: Dict) -> str:
        """ØªÙˆÙ„ÛŒØ¯ ØªÙˆÚ©Ù† Ø¯Ø³ØªØ±Ø³ÛŒ JWT"""
        payload = {
            'user_id': user['user_id'],
            'email': user['email'],
            'permissions': user['permissions'],
            'exp': datetime.now() + config.JWT_EXPIRATION,
            'iat': datetime.now(),
            'type': 'access'
        }
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    async def _generate_refresh_token(self, user: Dict) -> str:
        """ØªÙˆÙ„ÛŒØ¯ ØªÙˆÚ©Ù† Ø±ÙØ±Ø´ JWT"""
        payload = {
            'user_id': user['user_id'],
            'exp': datetime.now() + timedelta(days=30),
            'iat': datetime.now(),
            'type': 'refresh'
        }
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    async def verify_token(self, token: str) -> Tuple[bool, Dict]:
        """Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ØªÙˆÚ©Ù† JWT"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return True, payload
        except jwt.ExpiredSignatureError:
            self._log_security_event('TOKEN_EXPIRED', "JWT token expired")
            return False, {'error': 'Token expired'}
        except jwt.InvalidTokenError as e:
            self._log_security_event('TOKEN_INVALID', f"Invalid JWT token: {e}")
            return False, {'error': 'Invalid token'}
    
    async def _hash_password(self, password: str) -> str:
        """Ù‡Ø´ Ú©Ø±Ø¯Ù† Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ bcrypt"""
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    async def _verify_password(self, password: str, hashed_password: str) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ ØªØ·Ø§Ø¨Ù‚ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±"""
        try:
            return bcrypt.checkpw(
                password.encode('utf-8'), 
                hashed_password.encode('utf-8')
            )
        except Exception as e:
            self.logger.error(f"Password verification error: {e}")
            return False
    
    def _generate_user_id(self) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ø´Ù†Ø§Ø³Ù‡ ÛŒÚ©ØªØ§ÛŒ Ú©Ø§Ø±Ø¨Ø±"""
        return f"user_{secrets.token_hex(8)}"
    
    def _generate_google_auth_secret(self) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ Ù…Ø®ÙÛŒ Ø¨Ø±Ø§ÛŒ Google Authenticator"""
        return base64.b32encode(secrets.token_bytes(10)).decode('utf-8')
    
    def _generate_api_key(self) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ API"""
        return f"fa_{secrets.token_hex(16)}"
    
    async def _generate_google_auth_qr_code(self, email: str, secret: str) -> str:
        """ØªÙˆÙ„ÛŒØ¯ QR code Ø¨Ø±Ø§ÛŒ Google Authenticator"""
        try:
            # Ø³Ø§Ø®Øª URI Ø¨Ø±Ø§ÛŒ Google Authenticator
            issuer = "Financial Analyzer Pro"
            auth_uri = f"otpauth://totp/{issuer}:{email}?secret={secret}&issuer={issuer}"
            
            # ØªÙˆÙ„ÛŒØ¯ QR code
            qr = qrcode.QRCode(version=1, box_size=10, border=5)
            qr.add_data(auth_uri)
            qr.make(fit=True)
            
            img = qr.make_image(fill_color="black", back_color="white")
            
            # ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ base64
            buffer = io.BytesIO()
            img.save(buffer, format='PNG')
            buffer.seek(0)
            
            img_str = base64.b64encode(buffer.getvalue()).decode()
            
            return f"data:image/png;base64,{img_str}"
            
        except Exception as e:
            self.logger.error(f"Error generating QR code: {e}")
            return ""
    
    def _generate_totp_code(self, secret: str) -> str:
        """ØªÙˆÙ„ÛŒØ¯ Ú©Ø¯ TOTP (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)"""
        # Ø¯Ø± Ø¹Ù…Ù„ Ø¨Ø§ÛŒØ¯ Ø§Ø² Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ pyotp Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´ÙˆØ¯
        import time
        current_time = int(time.time()) // 30
        return f"{current_time % 1000000:06d}"[-6:]
    
    def _validate_user_data(self, user_data: Dict) -> Tuple[bool, List[str]]:
        """Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±"""
        errors = []
        
        if 'email' not in user_data:
            errors.append("Email is required")
        elif not self._is_valid_email(user_data['email']):
            errors.append("Invalid email format")
        
        if 'password' not in user_data:
            errors.append("Password is required")
        elif len(user_data['password']) < 8:
            errors.append("Password must be at least 8 characters")
        
        if 'mobile' in user_data and not self._is_valid_mobile(user_data['mobile']):
            errors.append("Invalid mobile number format")
        
        return len(errors) == 0, errors
    
    def _is_valid_email(self, email: str) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯Ù† Ø§ÛŒÙ…ÛŒÙ„"""
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    def _is_valid_mobile(self, mobile: str) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯Ù† Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„"""
        import re
        pattern = r'^\+?[1-9]\d{1,14}$'
        return re.match(pattern, mobile) is not None
    
    async def _get_user_by_identifier(self, identifier: str) -> Optional[Dict]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ù…ÙˆØ¨Ø§ÛŒÙ„ (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)"""
        # Ø¯Ø± Ø¹Ù…Ù„ Ø¨Ø§ÛŒØ¯ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´ÙˆØ¯
        # Ø§ÛŒÙ†Ø¬Ø§ ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ù†Ù…ÙˆÙ†Ù‡ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†ÛŒÙ…
        return {
            'user_id': 'user_sample_123',
            'email': 'user@example.com',
            'mobile': '+1234567890',
            'password_hash': await self._hash_password('password123'),
            'security': {
                'google_auth_secret': 'JBSWY3DPEHPK3PXP',
                'two_factor_enabled': True,
                'login_attempts': 0,
                'account_locked': False,
                'last_login': None
            },
            'permissions': self._get_default_permissions()
        }
    
    async def _get_user_by_id(self, user_id: str) -> Optional[Dict]:
        """Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ Ø´Ù†Ø§Ø³Ù‡ (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)"""
        # Ù…Ø´Ø§Ø¨Ù‡ ØªØ§Ø¨Ø¹ Ø¨Ø§Ù„Ø§
        return await self._get_user_by_identifier('user@example.com')
    
    async def _verify_two_factor(self, user: Dict, code: str) -> bool:
        """ØªØ£ÛŒÛŒØ¯ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ø¯Ùˆ Ù…Ø±Ø­Ù„Ù‡â€ŒØ§ÛŒ"""
        if not code:
            return False
        
        # Ø§ÙˆÙ„ Ø¨Ø±Ø±Ø³ÛŒ Google Authenticator
        if await self.verify_google_auth(user['user_id'], code):
            return True
        
        # Ø³Ù¾Ø³ Ø¨Ø±Ø±Ø³ÛŒ SMS
        if user.get('mobile') and await self.verify_sms_code(user['mobile'], code):
            return True
        
        return False
    
    def _get_default_permissions(self) -> List[str]:
        """Ù…Ø¬ÙˆØ²Ù‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ú©Ø§Ø±Ø¨Ø±"""
        return [
            'read_market_data',
            'view_signals', 
            'access_basic_analysis',
            'manage_own_portfolio'
        ]
    
    def _sanitize_user_data(self, user: Dict) -> Dict:
        """Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ú©Ù„Ø§ÛŒÙ†Øª"""
        sanitized = user.copy()
        
        # Ø­Ø°Ù ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ø­Ø³Ø§Ø³
        sanitized.pop('password_hash', None)
        sanitized['security'].pop('google_auth_secret', None)
        sanitized['security'].pop('api_key', None)
        
        return sanitized
    
    def _log_security_event(self, event_type: str, message: str, user_id: str = None):
        """Ø«Ø¨Øª Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø§Ù…Ù†ÛŒØªÛŒ"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_type': event_type,
            'message': message,
            'user_id': user_id,
            'ip_address': '127.0.0.1'  # Ø¯Ø± Ø¹Ù…Ù„ Ø¨Ø§ÛŒØ¯ Ø§Ø² request Ú¯Ø±ÙØªÙ‡ Ø´ÙˆØ¯
        }
        
        self.security_log.append(log_entry)
        self.logger.info(f"ğŸ”’ SECURITY: {event_type} - {message}")
    
    async def get_security_log(self, limit: int = 100) -> List[Dict]:
        """Ø¯Ø±ÛŒØ§ÙØª Ù„Ø§Ú¯ Ø§Ù…Ù†ÛŒØªÛŒ"""
        return self.security_log[-limit:]
    
    async def cleanup(self):
        """Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ù…Ù†Ø§Ø¨Ø¹"""
        self.logger.info("ğŸ§¹ Cleaning up Auth Manager resources...")
        self.verification_codes.clear()
        self.totp_secrets.clear()

# Ù†Ù…ÙˆÙ†Ù‡ Ø³ÛŒÙ†Ú¯Ù„ØªÙˆÙ† Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± Ø³Ø±Ø§Ø³Ø± Ø³ÛŒØ³ØªÙ…
auth_manager = AuthManager()
