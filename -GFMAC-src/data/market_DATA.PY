#!/usr/bin/env python3"""Market Data Management ModuleReal-time and Historical Data HandlingDeveloper: Seyed Aladdin Mousavi Jashni"""
import asyncioimport loggingimport aiohttpimport pandas as pdfrom datetime import datetime, timedeltafrom typing import Dict, List, Optionalimport jsonimport cachetools
from config import config
class MarketDataManager:    """مدیریت داده‌های بازار در زمان واقعی"""        def __init__(self):        self.logger = logging.getLogger(__name__)        self.session = None        self.cache = cachetools.TTLCache(maxsize=1000, ttl=300)  # کش ۵ دقیقه                # وضعیت اتصال به APIها        self.api_status = {            'alpha_vantage': 'disconnected',            'twelve_data': 'disconnected',            'oanda': 'disconnected'        }        async def initialize(self):        """مقداردهی اولیه مدیر داده‌های بازار"""        self.logger.info(" Initializing Market Data Manager...")                # ایجاد session برای درخواست‌های HTTP        self.session = aiohttp.ClientSession(            timeout=aiohttp.ClientTimeout(total=30)        )                # تست اتصال به APIها        await self._test_api_connections()                self.logger.info(" Market Data Manager initialized successfully!")        async def _test_api_connections(self):        """تست اتصال به APIهای مختلف"""        try:            # تست Alpha Vantage            async with self.session.get(                f"{config.API_CONFIG['ALPHA_VANTAGE']['BASE_URL']}?function=GLOBAL_QUOTE&symbol=IBM&apikey=demo"            ) as response:                if response.status == 200:                    self.api_status['alpha_vantage'] = 'connected'                        self.logger.info(f" API Status: {self.api_status}")                    except Exception as e:            self.logger.warning(f" Some API connections failed: {e}")        async def get_all_market_data(self) -> Dict:        """        دریافت کلیه داده‌های بازار                Returns:            Dict: داده‌های کامل بازار        """        try:            self.logger.info(" Fetching all market data...")                        market_data = {                'timestamp': datetime.now().isoformat(),                'forex': {},                'crypto': {},                'indices': {},                'metals': {},                'economic_events': []            }                        # دریافت داده‌های فارکس            market_data['forex'] = await self.get_forex_data()                        # دریافت داده‌های کریپتو            market_data['crypto'] = await self.get_crypto_data()                        # دریافت داده‌های شاخص‌ها            market_data['indices'] = await self.get_indices_data()                        # دریافت داده‌های فلزات گرانبها            market_data['metals'] = await self.get_metals_data()                        # دریافت رویدادهای اقتصادی            market_data['economic_events'] = await self.get_economic_calendar()                        self.logger.info(" Market data fetched successfully!")            return market_data                    except Exception as e:            self.logger.error(f" Failed to fetch market data: {e}")            return self._get_empty_market_data()        async def get_forex_data(self) -> Dict:        """دریافت داده‌های جفت ارزهای فارکس"""        forex_data = {}                for symbol in config.MONITORED_INSTRUMENTS['FOREX']:            try:                # بررسی کش                cache_key = f"forex_{symbol}"                if cache_key in self.cache:                    forex_data[symbol] = self.cache[cache_key]                    continue                                # شبیه‌سازی داده‌های واقعی                price_data = await self._simulate_forex_price(symbol)                forex_data[symbol] = price_data                                # ذخیره در کش                self.cache[cache_key] = price_data                            except Exception as e:                self.logger.error(f"Error fetching forex data for {symbol}: {e}")                forex_data[symbol] = self._get_error_price_data(symbol)                return forex_data        async def get_crypto_data(self) -> Dict:        """دریافت داده‌های ارزهای دیجیتال"""        crypto_data = {}                for symbol in config.MONITORED_INSTRUMENTS['CRYPTO']:            try:                cache_key = f"crypto_{symbol}"                if cache_key in self.cache:                    crypto_data[symbol] = self.cache[cache_key]                    continue                                # شبیه‌سازی داده‌های واقعی                price_data = await self._simulate_crypto_price(symbol)                crypto_data[symbol] = price_data                                self.cache[cache_key] = price_data                            except Exception as e:                self.logger.error(f"Error fetching crypto data for {symbol}: {e}")                crypto_data[symbol] = self._get_error_price_data(symbol)                return crypto_data        async def get_indices_data(self) -> Dict:        """دریافت داده‌های شاخص‌های سهام"""        indices_data = {}                for symbol in config.MONITORED_INSTRUMENTS['INDICES']:            try:                cache_key = f"indices_{symbol}"                if cache_key in self.cache:                    indices_data[symbol] = self.cache[cache_key]                    continue                                # شبیه‌سازی داده‌های واقعی                price_data = await self._simulate_index_price(symbol)                indices_data[symbol] = price_data                                self.cache[cache_key] = price_data                            except Exception as e:                self.logger.error(f"Error fetching indices data for {symbol}: {e}")                indices_data[symbol] = self._get_error_price_data(symbol)                return indices_data        async def get_metals_data(self) -> Dict:        """دریافت داده‌های فلزات گرانبها"""        metals_data = {}                for symbol in config.MONITORED_INSTRUMENTS['METALS']:            try:                cache_key = f"metals_{symbol}"                if cache_key in self.cache:                    metals_data[symbol] = self.cache[cache_key]                    continue                                # شبیه‌سازی داده‌های واقعی                price_data = await self._simulate_metal_price(symbol)                metals_data[symbol] = price_data                                self.cache[cache_key] = price_data                            except Exception as e:                self.logger.error(f"Error fetching metals data for {symbol}: {e}")                metals_data[symbol] = self._get_error_price_data(symbol)                return metals_data        async def get_economic_calendar(self) -> List[Dict]:        """دریافت تقویم اقتصادی"""        try:            # شبیه‌سازی رویدادهای اقتصادی            events = [                {                    'event': 'US Non-Farm Payrolls',                    'currency': 'USD',                    'importance': 'high',                    'actual': None,                    'forecast': '180K',                    'previous': '175K',                    'timestamp': (datetime.now() + timedelta(hours=2)).isoformat()                },                {                    'event': 'FOMC Meeting Minutes',                    'currency': 'USD',                     'importance': 'medium',                    'actual': None,                    'forecast': None,                    'previous': None,                    'timestamp': (datetime.now() + timedelta(days=1)).isoformat()                }            ]                        return events                    except Exception as e:            self.logger.error(f"Error fetching economic calendar: {e}")            return []        async def _simulate_forex_price(self, symbol: str) -> Dict:        """شبیه‌سازی قیمت فارکس"""        base_prices = {            'EUR/USD': 1.0850, 'GBP/USD': 1.2650, 'USD/JPY': 148.50,            'USD/CHF': 0.8850, 'AUD/USD': 0.6550, 'USD/CAD': 1.3550,            'NZD/USD': 0.6050, 'EUR/GBP': 0.8570        }                base_price = base_prices.get(symbol, 1.0)        volatility = 0.001  # 0.1% نوسان                return self._generate_price_data(symbol, base_price, volatility)        async def _simulate_crypto_price(self, symbol: str) -> Dict:        """شبیه‌سازی قیمت ارز دیجیتال"""        base_prices = {            'BTC/USD': 68500, 'ETH/USD': 3500, 'XRP/USD': 0.65,            'ADA/USD': 0.45, 'DOT/USD': 7.50, 'LTC/USD': 85.00,            'LINK/USD': 15.00, 'BCH/USD': 450.00        }                base_price = base_prices.get(symbol, 1000)        volatility = 0.02  # 2% نوسان                return self._generate_price_data(symbol, base_price, volatility)        async def _simulate_index_price(self, symbol: str) -> Dict:        """شبیه‌سازی قیمت شاخص سهام"""        base_prices = {            'SPX': 5200, 'NDX': 18000, 'DJI': 39000,            'FTSE': 8000, 'DAX': 18000, 'CAC': 8200,            'NIKKEI': 38000, 'ASX': 7700, 'HSI': 16500, 'SSE': 3000        }                base_price = base_prices.get(symbol, 5000)        volatility = 0.005  # 0.5% نوسان                return self._generate_price_data(symbol, base_price, volatility)        async def _simulate_metal_price(self, symbol: str) -> Dict:        """شبیه‌سازی قیمت فلزات گرانبها"""        base_prices = {            'XAU/USD': 2350, 'XAG/USD': 28.50,             'XPT/USD': 950, 'XPD/USD': 1050        }                base_price = base_prices.get(symbol, 1000)        volatility = 0.008  # 0.8% نوسان                return self._generate_price_data(symbol, base_price, volatility)        def _generate_price_data(self, symbol: str, base_price: float, volatility: float) -> Dict:        """تولید داده‌های قیمت شبیه‌سازی شده"""        import random        import numpy as np                # تولید قیمت با نوسان تصادفی        change_percent = np.random.normal(0, volatility)        current_price = base_price * (1 + change_percent)                # داده‌های حجم و تغییرات        volume = random.randint(1000, 100000)        change = current_price - base_price        change_percent_actual = (change / base_price) * 100                return {            'symbol': symbol,            'price': round(current_price, 5),            'change': round(change, 5),            'change_percent': round(change_percent_actual, 3),            'volume': volume,            'timestamp': datetime.now().isoformat(),            'high': round(current_price * (1 + volatility), 5),            'low': round(current_price * (1 - volatility), 5),            'open': round(base_price, 5)        }        def _get_error_price_data(self, symbol: str) -> Dict:        """داده‌های خطا در صورت شکست"""        return {            'symbol': symbol,            'price': 0.0,            'change': 0.0,            'change_percent': 0.0,            'volume': 0,            'timestamp': datetime.now().isoformat(),            'high': 0.0,            'low': 0.0,            'open': 0.0,            'error': True        }        def _get_empty_market_data(self) -> Dict:        """داده‌های خالی در صورت خطای کلی"""        return {            'timestamp': datetime.now().isoformat(),            'forex': {},            'crypto': {},            'indices': {},            'metals': {},            'economic_events': [],            'error': True        }        async def get_historical_data(self, symbol: str, period: str = "1mo") -> pd.DataFrame:        """        دریافت داده‌های تاریخی                Args:            symbol: نماد دارایی            period: بازه زمانی (1d, 1wk, 1mo, etc.)                    Returns:            pd.DataFrame: داده‌های تاریخی        """        try:            # اینجا باید از API واقعی استفاده شود            # برای نمونه داده‌های شبیه‌سازی شده برمی‌گردانیم                        dates = pd.date_range(end=datetime.now(), periods=30, freq='D')            prices = np.random.normal(100, 10, 30).cumsum()                        return pd.DataFrame({                'Date': dates,                'Close': prices,                'High': prices + np.random.uniform(1, 5, 30),                'Low': prices - np.random.uniform(1, 5, 30),                'Volume': np.random.randint(1000, 100000, 30)            })                    except Exception as e:            self.logger.error(f"Error fetching historical data for {symbol}: {e}")            return pd.DataFrame()        async def cleanup(self):        """پاک‌سازی منابع"""        self.logger.info(" Cleaning up Market Data Manager resources...")                if self.session:            await self.session.close()                self.cache.clear()
# نمونه سینگلتون برای استفاده در سراسر سیستمmarket_data_manager = MarketDataManager()
